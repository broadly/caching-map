{"name":"Caching-map","tagline":"LRU cache for people who like ES6 and promises","body":"# LRU cache for people who like ES6 and promises\r\n\r\nThis is an in-memory cache for JavaScript objects.  The API is similar to the\r\nES6 `Map` class, which is also an in-memory cache for JavaScript objects, but\r\nyou get a few additional features:\r\n\r\n* You can set the cache limit to 0 or Infinity, effectively enable/disable\r\n  caching (e.g. running code in development and production)\r\n* You can set the cache limit to any value between 0 and Infinity, deciding how\r\n  much you want to hold in memory\r\n* You can set the cost for each individual key, for smarter memory usage\r\n* You can set expiration for each individual key, afterwhich the key is no\r\n  longer available, making room for new keys\r\n* Expired keys are evicted first to make room for new keys, followed by least\r\n  recently used keys\r\n* You can iterate over all keys from most to least recently used\r\n* The materialize callback is easy  for caching asynchronous resources (database\r\n  connections, HTTP resources, etc) while avoiding * Materialize function to\r\n  avoid thundering herds\r\n\r\n\r\n## Example\r\n\r\n```js\r\nconst Cache = require('caching-map');\r\n\r\n// Cache 10 most recently used documents\r\nconst documents = new Cache(10);\r\n\r\n// If key is missing, load document from file system\r\ndocuments.materialize = function(filename) {\r\n  return promisify(fs.readFile)(filename);\r\n}\r\n\r\n\r\n// filename -> promise(Buffer)\r\n//\r\n// Returns promise that resolves to the content of this file\r\n// File becomes the most recently used\r\nfunction loadDocument(filename) {\r\n  return documents.get(filename);\r\n}\r\n\r\n\r\n// -> [ filename ]\r\n//\r\n// Returns up to ten filenames of the most recently loaded documents\r\nfunction listDocuments() {\r\n  const filenames = [ ...documents.keys() ];\r\n  return filenames;\r\n}\r\n```\r\n\r\n\r\n### Limit and Cost\r\n\r\nWhen creating a new cache, the first constructor argument is the cache limit.\r\n\r\nThe second argument can be another cache, a `Map`, or any iterator that returns\r\nname/value pairs.  You can easily create a new cache from a map (`new Cache(limit,\r\nmap)`), or turn a cache into a map (`new Map(cache)`).\r\n\r\nIf you set the cache limit to zero (or negative number), it will hold zero keys.\r\nThis could be useful when you want to use the same object in different\r\nconfigurations, e.g. cache in production but always live load in development.\r\n\r\nIf you set the cache limit to infinity, it will hold as many keys as you've got.\r\nThis is useful if you want cache features, but don't care about memory usage.\r\nFor example, flipping between caching all or nothing, using TTL to expire old\r\nvalues, or tracking most recently used keys:\r\n\r\n```js\r\n// Cache keys in production, always live load in development\r\n// For example, for caching templates\r\nconst limit = (NODE.ENV === 'production') ? Infinity : 0;\r\nconst cache = new Cache(limit);\r\n```\r\n\r\nYou can use the `limit` property to change the cache limit at any time.\r\nChanging the limit doesn't evict any keys until the cache needs to make room for\r\nnew keys.\r\n\r\n\r\n### Setting Keys\r\n\r\nWhen you set a key, that key becomes the most recently used.\r\n\r\nWhen you set a key, if the cache runs into its storage limit, it will start\r\nevicting (deleting) keys until it has room to store the new key.  It will first\r\nevict any expired keys, and then evict the least recently used keys.\r\n\r\nWhen setting a key, you can associate a cost for that key.  The default is one,\r\nso the default behavior is to limit the number of keys stored in the cache:\r\n\r\n```js\r\ncache.limit = 2;\r\ncache\r\n  .set('x', 'XXX')\r\n  .set('y', 'YYY')\r\n  .set('z', 'ZZZ');\r\ncache.size\r\n=> 2\r\n[ ...cache.keys() ]\r\n=> [ 'z', 'y' ]\r\n```\r\n\r\nHowever, if you are able to calculate a more accurate cost for each of the keys\r\n(e.g. the size of a string), you can use that for better memory usage:\r\n\r\n```js\r\nconst x = 'X';\r\nconst y = 'YYYY';\r\n\r\ncache.set('x', x, { cost: Buffer.byteLength(x) });\r\n[ cache.size, cache.cost ]\r\n=> [ 1, 1 ]\r\n\r\ncache.set('y', y, { cost: Buffer.byteLength(y) });\r\n[ cache.size, cache.cost ]\r\n=> [ 2, 5 ]\r\n```\r\n\r\nWhen setting a key, you can associate the time to live (in milliseconds).  Once\r\nthat time has passed, the key is expired.  Expired keys are removed first to\r\nmake room for new keys.  There is no way to retrieve the value of an expired\r\nkey:\r\n\r\n```js\r\nconst ttl = ms('1h');\r\n\r\ncache.set('key', 'good for an hour', { ttl });\r\ncache.get('key');\r\n=> 'good for an hour'\r\n\r\nsetTimeout(function() {\r\n  cache.get('key');\r\n}, ttl);\r\n=> undefined\r\n```\r\n\r\nIf a key expires immediately (TTL is zero or negative), or if the key cost is\r\nlarger than the limit, then that key is not stored, and no other key is evicted.\r\n\r\n\r\n### Get\r\n\r\nWhen you retrieve a key (`get(key)`), that key becomes the most recently used\r\nkey.  It will be the last key removed to make room for new keys, and the first\r\nkey returned when iterating through the keys.\r\n\r\nIn contrast, checking whether a key exists (`has(key)`), or iterating over keys,\r\ndoes not change their order.  Only getting or setting a key changes it to most\r\nrecent.\r\n\r\n\r\n### Iterate\r\n\r\nThe default iterator, `entries()`, `keys()` and `values()` are all available, as\r\nwell as `forEach`.  Since this is an LRU cache, they all iterate on entries\r\nbased on their caching order: from most to least recently used.\r\n\r\nYou can use iteration for operations like deleting keys based on a pattern,\r\nlisting all keys, and so forth:\r\n\r\n```js\r\nfunction deleteKeysInNamespace(cache, namespace) {\r\n  const prefix = `${namespace}:`;\r\n  for (let key of cache)\r\n    if (key.startsWith(prefix))\r\n      cache.delete(key);\r\n}\r\n\r\nfunction listAllKeys(cache) {\r\n  return [ ...cache.keys() ];\r\n}\r\n```\r\n\r\nJust watch out, iteration is O(N), and will be expensive for caches with many\r\nkeys.\r\n\r\n\r\n### Lazy Expiration\r\n\r\nExpired keys are lazily evicted from the cache, either to make room for new\r\nkeys, or when attempting to retrieve, check existence or iterate over the\r\nexpired key.\r\n\r\nIf you want to force evict all expired keys, you need to do so yourself, by\r\niterating over all keys:\r\n\r\n```js\r\nfunction evictExpiredKeys() {\r\n  // Iterating over expired key removes it from the cache\r\n  for (let entry of cache) ;\r\n}\r\n\r\nsetTimeout(evictExpiredKeys, ms('5m'));\r\n```\r\n\r\nDon't forget that whenever you read the `size` or `cost` of the cache, that\r\nvalue may include expired keys that are still in the cache but no longer\r\naccessible.\r\n\r\n\r\n### The Materialize Function\r\n\r\nA common pattern for caching code is to retrieve a key, and when the key doesn't\r\nexist, resolve and store the value.  This easily leads to the [Thundering herd\r\nproblem](https://en.wikipedia.org/wiki/Thundering_herd_problem).\r\n\r\nFor example, if you have 100 concurrent requests that all need to render the\r\nsame data, but the cache is empty, you may end up with 100 database queries\r\nattempting to set a single cache key.\r\n\r\nThe simplest solution is to cache a promise that resolves to that value.  That\r\nway, everyone is waiting for that one promise to resolve once.  However, if an\r\nerror occurs and the promise is rejected, you want to remove it from the cache,\r\nso a new promise can take its place.\r\n\r\nThe materialize function is a convenient way to implement this pattern.  When a\r\nkey has no value, this function is called with the key, and should return the\r\nexpected value, or a promise that resolves to that value.  For example:\r\n\r\n```js\r\ncache.materialize = function(url) {\r\n  return promisify(request)(url);\r\n};\r\n\r\nconst URL = 'http://example.com/';\r\n\r\ncache.get(URL).then(\r\n  function(result) {\r\n    // We cached a promise that always resolves to this response\r\n    console.log(result.body);\r\n\r\n    assert( cache.has(URL) );\r\n  },\r\n  function(error) {\r\n    // The promise is no longer in the cache, we can try again\r\n    assert( !cache.has(URL) );\r\n  });\r\n\r\n```\r\n\r\nIf you want to set the cost and/or expiration for that key, returns a promise,\r\nbut also set the key when that promise resolves:\r\n\r\n```js\r\ncache.materialize = function(url) {\r\n  const promise = promisify(request)(url);\r\n\r\n  promise.then(function(response) {\r\n\r\n    const cost = response.body.length;\r\n    cache.set(url, promise, { cost });\r\n\r\n  });\r\n  return promise;\r\n};\r\n```\r\n\r\n\r\n## License\r\n\r\nMIT License Copyright (c) 2015 Broadly Inc\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}